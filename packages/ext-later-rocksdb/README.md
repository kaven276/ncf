# 延迟服务场景

* 解耦。可最终一致的处理步骤。如下单成功，延迟零秒发送短信通知。这样发送短信服务是否可用只要进入任务队列，就最终会执行，从而解耦提高处理反馈速度，提高服务可用性。
* 如指定时长内没有支付，则自动关单
* 当任务队列中的任务执行失败，自动继续延迟重试

# 延迟服务

* 采用标准的 http 服务来接受延迟任务请求。
  - http 服务接口背后的实现，可以是基于 leveldb/rocksdb 的实现，也可以替换成任何实现。
  - NCF faas 做延迟调用的背后，只需要向 http 延迟服务发送标准 http 请求即可。
  - 这样的设计，NCF 服务无需引入特定协议的支持软件包，保持 NCF 的简单性。
  - 后面也可能引用 http2，来提升性能。甚至能延迟执行带请求 stream 的任务。
* 延迟服务单进程
  - 可以通过 k8s 单 pod 来保证，同时支持自动失败重启
  - 延迟服务如果使用 leveldb/rocksdb 等嵌入式数据库，也只能单进程访问
* 延迟队列的实现
  - 目前采用基于 rocksdb 实现，数据文件必须落到可靠存储上才能保证安全
  - 不采用基于 MQ 的实现，因为现有 MQ 并不针对延迟设计，性能上可能设计不足。另外进入 MQ 需要引入额外的服务或基础设施增加的运维的工作。
  - 但是 MQ 的一个好处是，一般有监控和管理的配套工具，API 的命令行的或者 web 页面的。
* 在 kv 中的编码
  - key 为 js Date 时间戳数字
  - value 为 [path,request,retry,pushTime] tuple 格式，减少固定的 key 在每条消息中的重复浪费。


# implementation

本 package 基于嵌入式 rocksdb 实现延迟任务队列。

# 使用

环境变量

1. PORT 本服务监听端口，默认 7779
2. NCF_HOST 如 `127.0.0.1:8000`，配置任务执行调用的 NCF 服务的地址
