所有 flow module 在这里统一 import 拉起

设计考量
========
* 通过一个 flow async function 中间调用和等待其他 faas 来定义工作流，无需学习特别的 DSL 工作流
  - 但是执行过程不是该 flow async funtion 的执行，而是将其通过 babel 转换成 AST 并形成一个流程定义
  - AST 转化来的流程定义将在流程引擎上执行，不受直接执行 js 函数对于长期性的影响
  - 相当于一个 js/ts 异步函数描述的工作流可以长时间的执行，所处进程重启也能完全恢复继续执行
  - 基于 AST + log 来查看流程执行的情况，可以转换成 bpmn 流程定义格式，并使用 bpmn.js 显示。
  - 优势是全 typescript 串接整个流程，开发方便，直接利用 js/ts 的循环，分支，计算和调度能力。类似前端的 react 进通过 js/ts 就能描述界面一样。js/ts 也一样可以直接描述流程。
* 从顶层一览流程全部，而不是将流程的控制代码分散到很多代码中。
  - 不是有上一步的 faas 来调用下一步的 faas，而是上一步的 faas 执行完，能通知到所处的流程实例，然后有流程代码来决定后续的处理。
  - 参与流程的 faas 只负责其中一个步骤的原子操作，能被流程调度即可。
  - 在流程代码中方便的实现如某步骤处理完成，则通知相关干系人知晓的逻辑
  - 流程中后面的代码可以拿到前面所有 faas 处理的请求响应信息，来支持流程的继续处理
* 时限和异常监控
  - 可以监控其中所有人工环节，机器环节的时间，是否比快要超时和已经超时，方便统一监控和告警通知
  - 通过失效监控确保整个业务流程满足效率要求
  - 某人工步骤或者自动步骤执行失败，需指定策略重试或者通知人工干预
* 人工介入支持
  - 如果流程处理中发现异常，需要停下，或者需要人工干预修正在继续处理，予以支持
* 支持 RPA 场景
  - RPA 对被监控系统的操作触发到达 ncf 服务调用，然后驱动 ncf 流程继续进行
  - ncf faas 可以发送给 RPA agent 操作被监控系统继续工作
* 长期运行 flow async function
  - 流程引用的所有 faas 因为 ncf 支持热更新，它们的升级无需停止 flow fn 所在进程
  - 流程函数本身变更了，老版本函数已经运行了流程实例，那么继续，但是新启动的流程使用新版本的流程函数
  - flow funtion 专有在 nodejs 进运行，中间调用其他 faas 都跨进程调用 ncf cluster 上的 faas 服务，全部内存只用于 flow function。
  - 采用 epoch 时代机制，每个 flow 进程只负责一代时间范围中发起的流程实例函数执行的持有，每天新开 epoch，或者当进程内存达到指定比例则自动开新 epoch
  - 如果最终 nodejs 内存还是吃紧，该进程可以中间退出一些 flow 函数释放内存，等该 flow 的消息进入，重新执行 flow fn 并通知日志恢复到断点续作
* waitFaas
  - waitFaas 如果由人工触发的，则上面定义通知函数，有工作流自动调用
* 父子工作流
  - faas 可以调用 flow 函数，flow fn 可以调用子流程的 flow fn
  - 调用 flow 函数，都采用异步跨进程方式，确保需长期执行的 flow fn 在自己专用的进程中执行

参考
====
* [一个Netflix开发的微服务编排引擎，支持可视化工作流定义](https://zhuanlan.zhihu.com/p/78925640)
* [分布式多步骤事务](https://help.aliyun.com/document_detail/122482.html)
* [Serverless 工作流](https://www.aliyun.com/product/fnf)
